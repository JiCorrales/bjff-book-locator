-- MySQL Script generated by MySQL Workbench
-- Sun Oct 26 20:40:06 2025
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';

-- -----------------------------------------------------
-- Schema mydb
-- -----------------------------------------------------
-- -----------------------------------------------------
-- Schema bjff_book_locator
-- -----------------------------------------------------

-- -----------------------------------------------------
-- Schema bjff_book_locator
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `bjff_book_locator` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci ;
USE `bjff_book_locator` ;

-- -----------------------------------------------------
-- Table `bjff_book_locator`.`Users`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `bjff_book_locator`.`Users` (
  `userID` INT NOT NULL,
  `firstName` VARCHAR(45) NOT NULL,
  `lastName` VARCHAR(45) NOT NULL,
  `email` VARCHAR(255) NOT NULL,
  `password` VARCHAR(255) NOT NULL,
  -- Nuevos campos solicitados
  `isActive` TINYINT NULL DEFAULT 1,
  `isDeleted` TINYINT NULL DEFAULT 0,
  `createdAt` DATETIME NULL DEFAULT CURRENT_TIMESTAMP,
  `updatedAt` DATETIME NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`userID`)
)
ENGINE = InnoDB
DEFAULT CHARACTER SET = utf8mb4
COLLATE = utf8mb4_unicode_ci;


-- -----------------------------------------------------
-- Table `bjff_book_locator`.`AdminProfiles`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `bjff_book_locator`.`AdminProfiles` (
  `userID` INT NOT NULL,
  PRIMARY KEY (`userID`),
  CONSTRAINT `fk_AdminProfiles_Users1`
    FOREIGN KEY (`userID`)
    REFERENCES `bjff_book_locator`.`Users` (`userID`))
ENGINE = InnoDB
DEFAULT CHARACTER SET = utf8mb4
COLLATE = utf8mb4_unicode_ci;


-- -----------------------------------------------------
-- Table `bjff_book_locator`.`AssistantProfiles`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `bjff_book_locator`.`AssistantProfiles` (
  `userID` INT NOT NULL,
  `tecID` VARCHAR(10) NOT NULL,
  PRIMARY KEY (`userID`, `tecID`),
  CONSTRAINT `fk_AssistantProfiles_Users1`
    FOREIGN KEY (`userID`)
    REFERENCES `bjff_book_locator`.`Users` (`userID`))
ENGINE = InnoDB
DEFAULT CHARACTER SET = utf8mb4
COLLATE = utf8mb4_unicode_ci;


-- -----------------------------------------------------
-- Table `bjff_book_locator`.`Module_types`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `bjff_book_locator`.`Module_types` (
  `module_type_id` INT NOT NULL AUTO_INCREMENT,
  `type_name` VARCHAR(50) NOT NULL COMMENT 'e.g., \"standard-double\", \"triangular\", \"circular-4\"',
  `type_part_count` INT NOT NULL COMMENT 'Number of faces this type must have',
  `type_description` TEXT NULL DEFAULT NULL,
  `is_active` TINYINT NULL DEFAULT '1',
  `created_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`module_type_id`),
  UNIQUE INDEX `uk_module_type_name` (`type_name` ASC) VISIBLE)
ENGINE = InnoDB
AUTO_INCREMENT = 2
DEFAULT CHARACTER SET = utf8mb4
COLLATE = utf8mb4_unicode_ci
COMMENT = 'Types of library modules (defines how many faces each has)';


-- -----------------------------------------------------
-- Table `bjff_book_locator`.`Modules`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `bjff_book_locator`.`Modules` (
  `module_id` INT NOT NULL AUTO_INCREMENT,
  `range_start` VARCHAR(30) NOT NULL COMMENT 'Start of code range (texto original)',
  `range_end` VARCHAR(30) NOT NULL COMMENT 'End of code range (texto original)',
  `key_start` CHAR(22) CHARACTER SET 'ascii' COLLATE 'ascii_bin' NOT NULL COMMENT 'Clave canónica fija',
  `key_end` CHAR(22) CHARACTER SET 'ascii' COLLATE 'ascii_bin' NOT NULL COMMENT 'Clave canónica fija',
  `module_name` VARCHAR(60) NULL DEFAULT NULL COMMENT 'Descriptive name',
  `module_number` INT NULL DEFAULT NULL COMMENT 'Physical module number (1..N)',
  `is_active` TINYINT NULL DEFAULT '1',
  `is_deleted` TINYINT NULL DEFAULT '0',
  `created_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `module_type_id` INT NOT NULL,
  PRIMARY KEY (`module_id`),
  UNIQUE INDEX `uk_module_number` (`module_number` ASC) VISIBLE,
  INDEX `idx_modules_type` (`module_type_id` ASC) VISIBLE,
  INDEX `idx_modules_keyrange` (`key_start` ASC, `key_end` ASC) VISIBLE,
  INDEX `idx_modules_order` (`module_number` ASC) VISIBLE,
  CONSTRAINT `fk_modules_module_types`
    FOREIGN KEY (`module_type_id`)
    REFERENCES `bjff_book_locator`.`Module_types` (`module_type_id`)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
ENGINE = InnoDB
AUTO_INCREMENT = 3
DEFAULT CHARACTER SET = utf8mb4
COLLATE = utf8mb4_unicode_ci;


-- -----------------------------------------------------
-- Table `bjff_book_locator`.`Module_parts`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `bjff_book_locator`.`Module_parts` (
  `module_part_id` INT NOT NULL AUTO_INCREMENT,
  `range_start` VARCHAR(30) NOT NULL,
  `range_end` VARCHAR(30) NOT NULL,
  `key_start` CHAR(22) CHARACTER SET 'ascii' COLLATE 'ascii_bin' NOT NULL,
  `key_end` CHAR(22) CHARACTER SET 'ascii' COLLATE 'ascii_bin' NOT NULL,
  `part_name` VARCHAR(60) NULL DEFAULT NULL COMMENT '\"front\",\"back\",\"A\",\"north\", etc.',
  `part_number` INT NULL DEFAULT NULL COMMENT 'Physical order within module (1..face_count)',
  `is_active` TINYINT NULL DEFAULT '1',
  `is_deleted` TINYINT NULL DEFAULT '0',
  `created_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `module_id` INT NOT NULL,
  PRIMARY KEY (`module_part_id`),
  UNIQUE INDEX `uk_part_name_per_module` (`module_id` ASC, `part_name` ASC) VISIBLE,
  UNIQUE INDEX `uk_part_order_per_module` (`module_id` ASC, `part_number` ASC) VISIBLE,
  INDEX `idx_parts_module` (`module_id` ASC) VISIBLE,
  INDEX `idx_parts_keyrange` (`key_start` ASC, `key_end` ASC) VISIBLE,
  INDEX `idx_parts_order` (`module_id` ASC, `part_number` ASC) VISIBLE,
  CONSTRAINT `fk_parts_modules`
    FOREIGN KEY (`module_id`)
    REFERENCES `bjff_book_locator`.`Modules` (`module_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
AUTO_INCREMENT = 5
DEFAULT CHARACTER SET = utf8mb4
COLLATE = utf8mb4_unicode_ci;


-- -----------------------------------------------------
-- Table `bjff_book_locator`.`Roles`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `bjff_book_locator`.`Roles` (
  `rolesID` INT NOT NULL,
  `name` VARCHAR(20) NOT NULL,
  PRIMARY KEY (`rolesID`))
ENGINE = InnoDB
DEFAULT CHARACTER SET = utf8mb4
COLLATE = utf8mb4_unicode_ci;


-- -----------------------------------------------------
-- Table `bjff_book_locator`.`Shelving_units`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `bjff_book_locator`.`Shelving_units` (
  `shelving_unit_id` INT NOT NULL AUTO_INCREMENT,
  `range_start` VARCHAR(30) NOT NULL,
  `range_end` VARCHAR(30) NOT NULL,
  `key_start` CHAR(22) CHARACTER SET 'ascii' COLLATE 'ascii_bin' NOT NULL,
  `key_end` CHAR(22) CHARACTER SET 'ascii' COLLATE 'ascii_bin' NOT NULL,
  `unit_name` VARCHAR(60) NULL DEFAULT NULL COMMENT 'Ej.: \"A\",\"B\",\"C\"',
  `unit_number` INT NULL DEFAULT NULL COMMENT 'Order within part (left→right)',
  `is_active` TINYINT NULL DEFAULT '1',
  `is_deleted` TINYINT NULL DEFAULT '0',
  `created_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `module_part_id` INT NOT NULL,
  PRIMARY KEY (`shelving_unit_id`),
  UNIQUE INDEX `uk_unit_name_per_part` (`module_part_id` ASC, `unit_name` ASC) VISIBLE,
  UNIQUE INDEX `uk_unit_order_per_part` (`module_part_id` ASC, `unit_number` ASC) VISIBLE,
  INDEX `idx_units_part` (`module_part_id` ASC) VISIBLE,
  INDEX `idx_units_keyrange` (`key_start` ASC, `key_end` ASC) VISIBLE,
  INDEX `idx_units_order` (`module_part_id` ASC, `unit_number` ASC) VISIBLE,
  CONSTRAINT `fk_units_parts`
    FOREIGN KEY (`module_part_id`)
    REFERENCES `bjff_book_locator`.`Module_parts` (`module_part_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
AUTO_INCREMENT = 33
DEFAULT CHARACTER SET = utf8mb4
COLLATE = utf8mb4_unicode_ci;


-- -----------------------------------------------------
-- Table `bjff_book_locator`.`Shelves`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `bjff_book_locator`.`Shelves` (
  `shelf_id` INT NOT NULL AUTO_INCREMENT,
  `range_start` VARCHAR(30) NOT NULL,
  `range_end` VARCHAR(30) NOT NULL,
  `key_start` CHAR(22) CHARACTER SET 'ascii' COLLATE 'ascii_bin' NOT NULL,
  `key_end` CHAR(22) CHARACTER SET 'ascii' COLLATE 'ascii_bin' NOT NULL,
  `shelf_number` INT NULL DEFAULT NULL COMMENT 'Top→bottom (1..N)',
  `is_active` TINYINT NULL DEFAULT '1',
  `is_deleted` TINYINT NULL DEFAULT '0',
  `created_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `shelving_unit_id` INT NOT NULL,
  PRIMARY KEY (`shelf_id`),
  UNIQUE INDEX `uk_shelf_order_per_unit` (`shelving_unit_id` ASC, `shelf_number` ASC) VISIBLE,
  INDEX `idx_shelves_unit` (`shelving_unit_id` ASC) VISIBLE,
  INDEX `idx_shelves_keyrange` (`key_start` ASC, `key_end` ASC) VISIBLE,
  INDEX `idx_shelves_order` (`shelving_unit_id` ASC, `shelf_number` ASC) VISIBLE,
  CONSTRAINT `fk_shelves_units`
    FOREIGN KEY (`shelving_unit_id`)
    REFERENCES `bjff_book_locator`.`Shelving_units` (`shelving_unit_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
ENGINE = InnoDB
AUTO_INCREMENT = 161
DEFAULT CHARACTER SET = utf8mb4
COLLATE = utf8mb4_unicode_ci;


-- -----------------------------------------------------
-- Table `bjff_book_locator`.`Users_Roles`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `bjff_book_locator`.`Users_Roles` (
  `userID` INT NOT NULL,
  `rolesID` INT NOT NULL,
  PRIMARY KEY (`userID`, `rolesID`),
  INDEX `fk_Users_has_Roles_Roles1_idx` (`rolesID` ASC) VISIBLE,
  INDEX `fk_Users_has_Roles_Users1_idx` (`userID` ASC) VISIBLE,
  CONSTRAINT `fk_Users_has_Roles_Roles1`
    FOREIGN KEY (`rolesID`)
    REFERENCES `bjff_book_locator`.`Roles` (`rolesID`),
  CONSTRAINT `fk_Users_has_Roles_Users1`
    FOREIGN KEY (`userID`)
    REFERENCES `bjff_book_locator`.`Users` (`userID`))
ENGINE = InnoDB
DEFAULT CHARACTER SET = utf8mb4
COLLATE = utf8mb4_unicode_ci;

USE `bjff_book_locator` ;

-- -----------------------------------------------------
-- Placeholder table for view `bjff_book_locator`.`vw_complete_structure`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `bjff_book_locator`.`vw_complete_structure` (`module_id` INT, `module_number` INT, `module_name` INT, `module_part_id` INT, `part_identifier` INT, `part_order` INT, `shelving_unit_id` INT, `unit_identifier` INT, `unit_order` INT, `shelf_id` INT, `shelf_order` INT, `shelf_range_start` INT, `shelf_range_end` INT, `shelf_key_start` INT, `shelf_key_end` INT, `full_location` INT);

-- -----------------------------------------------------
-- procedure find_book_location
-- -----------------------------------------------------

DELIMITER $$
USE `bjff_book_locator`$$
CREATE DEFINER=`root`@`%` PROCEDURE `find_book_location`(
    IN p_classification_code VARCHAR(30),
    IN p_comparable_key CHAR(22)
)
BEGIN
    -- Buscar el estante que contiene el código
    SELECT
        -- Información del módulo
        m.module_id,
        m.module_name AS module_name,
        m.range_start AS module_range_start,
        m.range_end AS module_range_end,
        mt.type_name AS module_type,
        m.module_number AS module_number,

        -- Información de la cara/parte del módulo
        mp.module_part_id,
        mp.part_name AS face_name,
        mp.range_start AS face_range_start,
        mp.range_end AS face_range_end,

        -- Información de la unidad de estantería
        su.shelving_unit_id,
        su.unit_name AS unit_name,
        su.range_start AS unit_range_start,
        su.range_end AS unit_range_end,

        -- Información del estante específico
        s.shelf_id,
        s.shelf_number AS shelf_level,
        s.range_start AS shelf_range_start,
        s.range_end AS shelf_range_end,

        -- Código buscado
        p_classification_code AS searched_code,
        p_comparable_key AS searched_key

    FROM Shelves s

    -- JOIN con unidad de estantería
    INNER JOIN Shelving_units su
        ON s.shelving_unit_id = su.shelving_unit_id

    -- JOIN con cara/parte del módulo
    INNER JOIN Module_parts mp
        ON su.module_part_id = mp.module_part_id

    -- JOIN con módulo
    INNER JOIN Modules m
        ON mp.module_id = m.module_id

    -- JOIN con tipo de módulo
    LEFT JOIN Module_types mt
        ON m.module_type_id = mt.module_type_id

    -- Condición de búsqueda: el código debe estar dentro del rango del estante
    WHERE p_comparable_key >= s.key_start
      AND p_comparable_key <= s.key_end

    -- Ordenar por nivel de estante (de arriba hacia abajo)
    ORDER BY s.shelf_number ASC

    -- Limitar a un solo resultado (el primer estante que contenga el libro)
    LIMIT 1;

END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure get_module_summary
-- -----------------------------------------------------

DELIMITER $$
USE `bjff_book_locator`$$
CREATE DEFINER=`root`@`%` PROCEDURE `get_module_summary`()
BEGIN
    SELECT
        m.module_id,
        m.module_name,
        m.module_number,
        mt.type_name AS module_type_name,
        m.range_start,
        m.range_end,
        m.key_start,
        m.key_end,
        COUNT(DISTINCT mp.module_part_id) AS total_faces,
        COUNT(DISTINCT su.shelving_unit_id) AS total_units,
        COUNT(DISTINCT s.shelf_id) AS total_shelves

    FROM Modules m
    LEFT JOIN Module_types mt ON m.module_type_id = mt.module_type_id
    LEFT JOIN Module_parts mp ON m.module_id = mp.module_id
    LEFT JOIN Shelving_units su ON mp.module_part_id = su.module_part_id
    LEFT JOIN Shelves s ON su.shelving_unit_id = s.shelving_unit_id

    GROUP BY m.module_id, m.module_name, m.module_number, mt.type_name,
             m.range_start, m.range_end, m.key_start, m.key_end

    ORDER BY m.module_id;

END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure search_books_in_range
-- -----------------------------------------------------

DELIMITER $$
USE `bjff_book_locator`$$
CREATE DEFINER=`root`@`%` PROCEDURE `search_books_in_range`(
    IN p_start_key CHAR(22),
    IN p_end_key CHAR(22)
)
BEGIN
    SELECT
        m.module_name,
        mp.part_name AS face_identifier,
        su.unit_name AS unit_identifier,
        s.shelf_number AS shelf_level,
        s.range_start,
        s.range_end,
        s.key_start,
        s.key_end

    FROM Shelves s
    INNER JOIN Shelving_units su ON s.shelving_unit_id = su.shelving_unit_id
    INNER JOIN Module_parts mp ON su.module_part_id = mp.module_part_id
    INNER JOIN Modules m ON mp.module_id = m.module_id

    -- Encontrar estantes cuyo rango intersecta con el rango buscado
    WHERE s.key_start <= p_end_key
      AND s.key_end >= p_start_key

    ORDER BY m.module_id, mp.face_identifier, su.unit_identifier, s.shelf_level;

END$$

DELIMITER ;

-- -----------------------------------------------------
-- View `bjff_book_locator`.`vw_complete_structure`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `bjff_book_locator`.`vw_complete_structure`;
USE `bjff_book_locator`;
CREATE  OR REPLACE ALGORITHM=UNDEFINED DEFINER=`root`@`%` SQL SECURITY DEFINER VIEW `bjff_book_locator`.`vw_complete_structure` AS select `m`.`module_id` AS `module_id`,`m`.`module_number` AS `module_number`,`m`.`module_name` AS `module_name`,`mp`.`module_part_id` AS `module_part_id`,`mp`.`part_name` AS `part_identifier`,`mp`.`part_number` AS `part_order`,`u`.`shelving_unit_id` AS `shelving_unit_id`,`u`.`unit_name` AS `unit_identifier`,`u`.`unit_number` AS `unit_order`,`s`.`shelf_id` AS `shelf_id`,`s`.`shelf_number` AS `shelf_order`,`s`.`range_start` AS `shelf_range_start`,`s`.`range_end` AS `shelf_range_end`,`s`.`key_start` AS `shelf_key_start`,`s`.`key_end` AS `shelf_key_end`,concat('Module ',coalesce(`m`.`module_number`,'?'),' - ',coalesce(`mp`.`part_name`,'?'),' - Unit ',coalesce(`u`.`unit_name`,`u`.`unit_number`),' - Shelf ',coalesce(`s`.`shelf_number`,'?')) AS `full_location` from (((`bjff_book_locator`.`modules` `m` join `bjff_book_locator`.`module_parts` `mp` on(((`mp`.`module_id` = `m`.`module_id`) and (`mp`.`is_deleted` = 0) and (`mp`.`is_active` = 1)))) join `bjff_book_locator`.`shelving_units` `u` on(((`u`.`module_part_id` = `mp`.`module_part_id`) and (`u`.`is_deleted` = 0) and (`u`.`is_active` = 1)))) join `bjff_book_locator`.`shelves` `s` on(((`s`.`shelving_unit_id` = `u`.`shelving_unit_id`) and (`s`.`is_deleted` = 0) and (`s`.`is_active` = 1)))) where ((`m`.`is_deleted` = 0) and (`m`.`is_active` = 1));

SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;
